<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>regex â€“ re-tutorial.lhs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="lib/lhs-styles.css">
  <link rel="stylesheet" href="lib/bs.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/>
  <link rel="manifest" href="/manifest.json"/>
  <link rel="mask-icon" href="/safari-pinned-tab.svg"/>
  <meta name="theme-color" content="#ffffff"/>
</head>
<body>
<div class='bcdiv'>
  <ol class='breadcrumb'>
    <li><a href="." style="font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;" id="branding">[<span style='color:red;'>re</span>|${<span style='color:red;'>gex</span>}(.*)|<span></span>]</a></li>
    <li><a title='source file' href='https://github.com/iconnect/regex/blob/master/examples/re-tutorial.lhs'>re-tutorial.lhs</a></li>
</ol>
</div>
<div class='litcontent'>
<header>
<h1 class="title">re-tutorial.lhs</h1>
</header>
<h1 id="the-regex-tutorial">The regex Tutorial</h1>
<p>This tutorial is a self-testing literate Haskell programme introducing the vanilla API of the <a href="http://hs.regex.uk">regex package</a>. There are other tutorials for explaining the more specialist aspects of regex and you can load them into into you Haskell REPL of choice: see the <a href="http://tutorial.regex.uk">regex Tutorials page</a> for details.</p>
<h2 id="language-pragmas">Language Pragmas</h2>
The first thing you will have to do is enable <code>QuasiQuotes</code> as regex uses them to check that REs are well-formed at compile time.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes                      #-}</span></code></pre></div>
<p>If you are trying out examples interactively at the ghci prompt then you will need</p>
<pre><code>:seti -XQuasiQuotes</code></pre>
<h2 id="importing-the-api">Importing the API</h2>
<p>Before importing the <code>regex</code> API into your Haskell script you will need to answer two questions:</p>
<ol type="1">
<li><p>Which flavour of REs do I need? If you need Posix REs then the <code>TDFA</code> is for you, otherwise it is the PCRE back end, which is housed in a seperate <code>regex-with-pcre</code> package.</p></li>
<li><p>Which Haskell type is being used for the text I need to match? This can influence as, at the time of writing, the <code>PCRE</code> <code>regex</code> back end <a href="https://github.com/iconnect/regex/issues/58">does not support the<code>Text</code> types</a>.</p></li>
</ol>
<p>The import statement will in general look like this</p>
<pre><code>  import Text.RE.&lt;back-end&gt;.&lt;text-type&gt;</code></pre>
<p>As we have no interest in Posix/PCRE distinctions or performance here, we have chosen to work with the <code>TDFA</code> back end with <code>String</code> types.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Text.RE.TDFA.String</span></code></pre></div>
<p>You could also import <code>Text.RE.TDFA</code> or <code>Text.RE.PCRE</code> to get an API in which the operators are overloaded over all text types accepted by each of these back ends: see the <a href="re-tutorial-tools.html">Tools Tutorial</a> for details.</p>
<h2 id="single-match-with">Single <code>Match</code> with <code>?=~</code></h2>
<p>The regex API provides two matching operators: one for looking for the first match in its search string and the other for finding all of the matches. The first-match operator, <code>?=~</code>, yields the result of attempting to find the first match.</p>
<pre><code>(?=~) :: String -&gt; RE -&gt; Match String</code></pre>
<p>The boolean <code>matched</code> function,</p>
<pre><code>matched :: Match a -&gt; Bool</code></pre>
can be used to test whether a match was found:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matched <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">?=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
<span class="dt">True</span></code></pre></div>
<p>To get the matched text use <code>matchText</code>,</p>
<pre><code>matchedText :: Match a -&gt; Maybe a</code></pre>
which returns <code>Nothing</code> if no match was found in the search string:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matchedText <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">?=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
<span class="dt">Just</span> <span class="st">&quot;2016-01-09&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matchedText <span class="fu">$</span> <span class="st">&quot;2015-12-5&quot;</span> <span class="fu">?=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
<span class="dt">Nothing</span></code></pre></div>
<h2 id="multiple-matches-with">Multiple <code>Matches</code> with <code>*=~</code></h2>
<p>Use <code>*=~</code> to locate all of the non-overlapping substrings that match a RE,</p>
<pre><code>(*=~)      :: String -&gt; RE -&gt; Matches String
anyMatches :: Matches a -&gt; Bool</code></pre>
<code>anyMatches</code> can be used to determine if any matches were found
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> anyMatches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
<span class="dt">True</span></code></pre></div>
and <code>countMatches</code> will tell us how many sub-strings matched:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
<span class="dv">2</span></code></pre></div>
<p><code>matches</code> will return all of the matches.</p>
<pre><code>matches :: Natches a -&gt; [a]</code></pre>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]
[<span class="st">&quot;2016-01-09&quot;</span>,<span class="st">&quot;2015-10-05&quot;</span>]</code></pre></div>
<h2 id="the-regex-macros-and-parsers">The <code>regex</code> Macros and Parsers</h2>
<p>regex supports macros in regular expressions. There are a bunch of standard macros that you can just use, and you can define your own.</p>
RE macros are enclosed in <code>@{</code> ... '}'. By convention the macros in the standard environment start with a '%'. <code>@{%date}</code> will match an ISO 8601 date, this
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> [re|@{%date}|]
<span class="dv">2</span></code></pre></div>
<p>will pick out the two dates.</p>
There are also parsing functions for analysing the matched text. The <code>@{%string}</code> macro will match quoted strings (in which double quotes can be escaped with backslashes in the usual way) and its companion <code>parseString</code> function will extract the string that was being quoted, interpreting any escaped double quotes:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> map parseString <span class="fu">$</span> matches <span class="fu">$</span> <span class="st">&quot;\&quot;foo\&quot;, \&quot;bar\&quot; and a quote \&quot;\\\&quot;\&quot;&quot;</span> <span class="fu">*=~</span> [re|@{%string}|]
[<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>,<span class="dt">Just</span> <span class="st">&quot;bar&quot;</span>, <span class="dt">Just</span> <span class="st">&quot;\&quot;&quot;</span>]</code></pre></div>
<p>See the <a href="http://macros.regex.uk">macro tables page</a> for details of the standard macros and their parsers.</p>
<p>See the <a href="re-tutorial-testbench.html">testbench tutorial</a> for more on how you can develop, document and test RE macros with the regex test bench.</p>
<h2 id="search-and-replace">Search and Replace</h2>
<p>If you need to edit a string then <code>SearchReplace</code> <code>[ed|</code> ... <code>|]</code> templates can be used with <code>?=~/</code> to replace a single instance or <code>*=~/</code> to replace all matching instances.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;0000 40AA fab0&quot;</span> <span class="fu">?=~/</span> [ed|${adr}([0-9A-Fa-f]{4}):?///0x${adr}:|]
<span class="st">&quot;0x0000: 40AA fab0&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;0000: 40AA fab0&quot;</span> <span class="fu">*=~/</span> [ed|[0-9A-Fa-f]{4}///0x$0|]
<span class="st">&quot;0x0000: 0x40AA 0xfab0&quot;</span></code></pre></div>
<h2 id="specifying-options">Specifying Options</h2>
By default regular expressions are of the multi-line case-sensitive variety so this
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;0a\nbb\nFe\nA5&quot;</span> <span class="fu">*=~</span> [re|[0-9a-f]{2}$|]
<span class="dv">2</span></code></pre></div>
<p>will find 2 matches, the '$' anchor matching each of the newlines, but only the first two lowercase hex numbers matching the RE. The case sensitivity and multiline-ness can be controled by selecting alternative parsers.</p>
<table style="width:97%;">
<colgroup>
<col style="width: 37%" />
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>long name</th>
<th>short forms</th>
<th>multiline</th>
<th>case sensitive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>reMultilineSensitive</p></td>
<td><p>reMS, re</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
</tr>
<tr class="even">
<td><p>reMultilineInsensitive</p></td>
<td><p>reMI</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="odd">
<td><p>reBlockSensitive</p></td>
<td><p>reBS</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="even">
<td><p>reBlockInsensitive</p></td>
<td><p>reBI</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
So while the default setup
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;0a\nbb\nFe\nA5&quot;</span> <span class="fu">*=~</span> [reMultilineSensitive|[0-9a-f]{2}$|]
<span class="dv">2</span></code></pre></div>
finds 2 matches, a case-insensitive RE
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;0a\nbb\nFe\nA5&quot;</span> <span class="fu">*=~</span> [reMultilineInsensitive|[0-9a-f]{2}$|]
<span class="dv">4</span></code></pre></div>
finds 4 matches, while a non-multiline RE
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;0a\nbb\nFe\nA5&quot;</span> <span class="fu">*=~</span> [reBlockSensitive|[0-9a-f]{2}$|]
<span class="dv">0</span></code></pre></div>
finds no matches but a non-multiline, case-insensitive match
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> <span class="st">&quot;0a\nbb\nFe\nA5&quot;</span> <span class="fu">*=~</span> [reBlockInsensitive|[0-9a-f]{2}$|]
<span class="dv">1</span></code></pre></div>
<p>finds the final match.</p>
For the hard of typing the shortforms are available.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matched <span class="fu">$</span> <span class="st">&quot;SuperCaliFragilisticExpialidocious&quot;</span> <span class="fu">?=~</span> [reMI|supercalifragilisticexpialidocious|]
<span class="dt">True</span></code></pre></div>
<h2 id="compiling-and-escaping">Compiling and Escaping</h2>
<p>It is possible to compile a dynamically aquired RE string at run-time using <code>compileRegex</code>:</p>
<pre><code>compileRegex :: (Functor m, Monad m) =&gt; String -&gt; m RE</code></pre>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> (either error id <span class="fu">$</span> compileRegex <span class="st">&quot;[0-9]{4}-[0-9]{2}-[0-9]{2}&quot;</span>)
[<span class="st">&quot;2016-01-09&quot;</span>,<span class="st">&quot;2015-10-05&quot;</span>]</code></pre></div>
<p>These will compile the RE using the default multiline, case-sensitive options, but you can specify the options dynamically using <code>compileRegexWith</code>:</p>
<pre><code>compileRegexWith :: (Functor m, Monad m) =&gt; SimpleREOptions -&gt; String -&gt; m RE</code></pre>
<p>where <code>SimpleREOptions</code> is a simple enumerated type.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | the default API uses these simple, universal RE options,</span>
<span class="co">-- which get auto-converted into the apropriate back-end &#39;REOptions_&#39;</span>
<span class="kw">data</span> <span class="dt">SimpleREOptions</span>
  <span class="fu">=</span> <span class="dt">MultilineSensitive</span>        <span class="co">-- ^ case-sensitive with ^ and $ matching the start and end of a line</span>
  <span class="fu">|</span> <span class="dt">MultilineInsensitive</span>      <span class="co">-- ^ case-insensitive with ^ and $ matsh the start and end of a line</span>
  <span class="fu">|</span> <span class="dt">BlockSensitive</span>            <span class="co">-- ^ case-sensitive with ^ and $ matching the start and end of the input text</span>
  <span class="fu">|</span> <span class="dt">BlockInsensitive</span>          <span class="co">-- ^ case-insensitive with ^ and $ matching the start and end of the input text</span>
  <span class="kw">deriving</span> (<span class="dt">Bounded</span>,<span class="dt">Enum</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>)</code></pre></div>
</div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matches <span class="fu">$</span> <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span> <span class="fu">*=~</span> (either error id <span class="fu">$</span> compileRegexWith <span class="dt">MultilineSensitive</span> <span class="st">&quot;[0-9]{4}-[0-9]{2}-[0-9]{2}&quot;</span>)
[<span class="st">&quot;2016-01-09&quot;</span>,<span class="st">&quot;2015-10-05&quot;</span>]</code></pre></div>
<p>If you need to compile <code>SearchReplace</code> templates for use with <code>?=~/</code> and <code>*=~/</code> then the <code>compileSearchReplace</code> and <code>compileSearchReplaceWith</code>,</p>
<pre><code>compileSearchReplace     :: (Monad m, Functor m, IsRegex RE s) =&gt; String -&gt; String -&gt; m (SearchReplace RE s)
compileSearchReplaceWith :: (Monad m, Functor m, IsRegex RE s) =&gt; SimpleREOptions -&gt; String -&gt; String -&gt; m (SearchReplace RE s)</code></pre>
<p>work analagously to <code>compileRegex</code> and <code>compileRegexWith</code>, with the RE and replacement template (either side of the '///' in the <code>[ed|...///...|]</code> quasi quoters) being passed into these functions in two separate strings, to compile to the <code>SearchReplace</code> type expected by the <code>?=~/</code> and <code>*=~/</code> operators.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | contains a compiled RE and replacement template</span>
<span class="kw">data</span> <span class="dt">SearchReplace</span> re s <span class="fu">=</span>
  <span class="dt">SearchReplace</span>
    {<span class="ot"> getSearch   ::</span> <span class="fu">!</span>re    <span class="co">-- ^ the RE to match a string to replace</span>
    ,<span class="ot"> getTemplate ::</span> <span class="fu">!</span>s     <span class="co">-- ^ the replacement template with ${cap}</span>
                            <span class="co">-- used to identify a capture (by number or</span>
                            <span class="co">-- name if one was given) and &#39;$$&#39; being</span>
                            <span class="co">-- used to escape a single &#39;$&#39;</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
</div>
<p>The <code>escape</code> and <code>escapeWith</code> functions are special compilers that compile a string into a RE that should match itself, which is assumed to be embedded in a complex RE to be compiled.</p>
<pre><code>escape :: (Functor m, Monad m) =&gt; (String-&gt;String) -&gt; String -&gt; m RE</code></pre>
The function pased in the first argument to <code>escape</code> takes the RE string that will match the string passed in the second argument and yields the RE to be compiled, which is returned from the parsing action.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;fooe{0}bar&quot;</span> <span class="fu">*=~/</span> <span class="dt">SearchReplace</span> (either error id <span class="fu">$</span> escape id <span class="st">&quot;e{0}&quot;</span>) <span class="st">&quot;&quot;</span>
<span class="st">&quot;foobar&quot;</span></code></pre></div>
<h2 id="the-classic-regex-base-match-operators">The Classic regex-base Match Operators</h2>
The original <code>=~</code> and <code>=~~</code> match operators are still available for those that have mastered them.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;bar&quot;</span>    <span class="fu">=~</span>  [re|(foo|bar)|]<span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="dt">True</span> </code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;quux&quot;</span>   <span class="fu">=~</span>  [re|(foo|bar)|]<span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="dt">False</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;foobar&quot;</span> <span class="fu">=~</span>  [re|(foo|bar)|]<span class="ot"> ::</span> <span class="dt">Int</span>
<span class="dv">2</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="st">&quot;foo&quot;</span>    <span class="fu">=~~</span> [re|bar|]<span class="ot">       ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
<span class="dt">Nothing</span></code></pre></div>
</div>    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-92650418-1', 'auto');
      ga('send', 'pageview');

    </script>
</body>
</html>
