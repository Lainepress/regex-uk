<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>regex â€“ re-tutorial-replacing.lhs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="lib/lhs-styles.css">
  <link rel="stylesheet" href="lib/bs.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/>
  <link rel="manifest" href="/manifest.json"/>
  <link rel="mask-icon" href="/safari-pinned-tab.svg"/>
  <meta name="theme-color" content="#ffffff"/>
</head>
<body>
<div class='bcdiv'>
  <ol class='breadcrumb'>
    <li><a href="." style="font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;" id="branding">[<span style='color:red;'>re</span>|${<span style='color:red;'>gex</span>}(.*)|<span></span>]</a></li>
    <li><a title='source file' href='https://github.com/iconnect/regex/blob/master/examples/re-tutorial-replacing.lhs'>re-tutorial-replacing.lhs</a></li>
</ol>
</div>
<div class='litcontent'>
<header>
<h1 class="title">re-tutorial-replacing.lhs</h1>
</header>
<h1 id="the-regex-replacing-tutorial">The regex Replacing Tutorial</h1>
<h2 id="language-options-and-imports">Language Options and Imports</h2>
<p>This tutorial is a literate Haskell program whwre we start by specifying the language pragmas and imports we will need for this module.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes                      #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import           </span><span class="dt">Text.RE.Replace</span>
<span class="kw">import           </span><span class="dt">Text.RE.TDFA.String</span></code></pre></div>
<h2 id="simple-text-replacement">Simple Text Replacement</h2>
<p>regex supports the replacement of matched text with alternative text. This section will cover replacement text specified with templates. More flexible tools that allow functions calculate the replacement text are covered below.</p>
<p><em>Capture</em> sub-expressions, whose matched text can be inserted into the replacement template, can be specified as follows:</p>
<ul>
<li><p><code>$(</code> ... <code>)</code> identifies a capture that can be identified by its left-to-right position relative to the other captures in the replacement template, with <code>$1</code> being used to represent the leftmost capture, <code>$2</code> the next leftmost capture, and so on;</p></li>
<li><p><code>${foo}(</code> ... <code>)</code> can be used to identify a capture by name. Such captures can be identified either by their left-to-right position in the regular expression or by <code>${foo}</code> in the template.</p></li>
</ul>
A function to convert ISO format dates into a UK-format date could be written thus:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">uk_dates ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
uk_dates src <span class="fu">=</span>
  replaceAll <span class="st">&quot;${d}/${m}/${y}&quot;</span> <span class="fu">$</span> src <span class="fu">*=~</span> [re<span class="fu">|$</span>{y}([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">4</span>})<span class="fu">-$</span>{m}([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>})<span class="fu">-$</span>{d}([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>})<span class="fu">|</span>]</code></pre></div>
with
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> uk_dates <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>
<span class="st">&quot;09/01/2016 2015-12-5 05/10/2015&quot;</span></code></pre></div>
The same function written with numbered captures:
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">uk_dates&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
uk_dates&#39; src <span class="fu">=</span>
  replaceAll <span class="st">&quot;$3/$2/$1&quot;</span> <span class="fu">$</span> src <span class="fu">*=~</span> [re<span class="fu">|$</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">4</span>})<span class="fu">-$</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>})<span class="fu">-$</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>})<span class="fu">|</span>]</code></pre></div>
with
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> uk_dates&#39; <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>
<span class="st">&quot;09/01/2016 2015-12-5 05/10/2015&quot;</span></code></pre></div>
<p>yielding the same result.</p>
<p>(Most regex conventions use plain parentheses, <code>(</code> ... <code>)</code>, to mark captures but we would like to reserve those exclusively for grouping in regex REs.)</p>
<h2 id="matchesmatchcapture">Matches/Match/Capture</h2>
<p>The types returned by the <code>?=~</code> and <code>*=~</code> form the foundations of the package. Understandingv these simple types is the key to understanding the package.</p>
The type of <code>*=~</code> in this module (imported from <code>Text.RE.TDFA.String</code>) is:
<div class="inlinecodeblock">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(*=~) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RE</span> <span class="ot">-&gt;</span> <span class="dt">Matches</span> <span class="dt">String</span></code></pre></div>
</div>
<p>with <code>Matches</code> defined in <code>Text.RE.ZeInternals.Types.Capture</code> thus:</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | the result of matching a RE against a text (with @*=~@), retaining</span>
<span class="co">-- the text that was matched against</span>
<span class="kw">data</span> <span class="dt">Matches</span> a <span class="fu">=</span>
  <span class="dt">Matches</span>
    {<span class="ot"> matchesSource ::</span> <span class="fu">!</span>a          <span class="co">-- ^ the source text being matched</span>
    ,<span class="ot"> allMatches    ::</span> <span class="fu">!</span>[<span class="dt">Match</span> a]  <span class="co">-- ^ all &#39;Match&#39; instances found, left to right</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Typeable</span>)</code></pre></div>
</div>
<p>The critical component of the <code>Matches</code> type is the <code>[Match a]</code> in <code>allMatches</code>, containing the details all of each substring matched by the RE. The <code>matchSource</code> component also retains a copy of the original search string but the critical information is in <code>allmatches</code>.</p>
The type of <code>?=~</code> in this module (imported from <code>Text.RE.TDFA.String</code>) is:
<div class="inlinecodeblock">
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(?=~) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RE</span> <span class="ot">-&gt;</span> <span class="dt">Match</span> <span class="dt">String</span></code></pre></div>
</div>
<p>with <code>Match</code> (referenced in the definition of <code>Matches</code> above) defined in <code>Text.RE.ZeInternals.Types.Capture</code> thus:</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | the result of matching a RE to a text once (with @?=~@), retaining</span>
<span class="co">-- the text that was matched against</span>
<span class="kw">data</span> <span class="dt">Match</span> a <span class="fu">=</span>
  <span class="dt">Match</span>
    {<span class="ot"> matchSource  ::</span> <span class="fu">!</span>a                <span class="co">-- ^ the whole source text</span>
    ,<span class="ot"> captureNames ::</span> <span class="fu">!</span><span class="dt">CaptureNames</span>     <span class="co">-- ^ the RE&#39;s capture names</span>
    ,<span class="ot"> matchArray   ::</span> <span class="fu">!</span>(<span class="dt">Array</span> <span class="dt">CaptureOrdinal</span> (<span class="dt">Capture</span> a))
                                        <span class="co">-- ^ 0..n-1 captures,</span>
                                        <span class="co">-- starting with the</span>
                                        <span class="co">-- text matched by the</span>
                                        <span class="co">-- whole RE</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>,<span class="dt">Typeable</span>)</code></pre></div>
</div>
<p>Like <code>matchesSource</code> above, <code>matchSource</code> retains the original search string, but also a <code>CaptureNames</code> field listing all of the capture names in the RE (needed by the text replacemnt tools).</p>
<p>But the 'real' content of <code>Match</code> is to be found in the <code>MatchArray</code>, enumerating all of the substrings captured by this match, starting with <code>0</code> for the substring captured by the whole RE, <code>1</code> for the leftmost explicit capture in the RE, <code>2</code> for the next leftmost capture, and so on.</p>
<p>Each captured substring is represented by the following <code>Capture</code> type:</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | the matching of a single sub-expression against part of the source</span>
<span class="co">-- text</span>
<span class="kw">data</span> <span class="dt">Capture</span> a <span class="fu">=</span>
  <span class="dt">Capture</span>
    {<span class="ot"> captureSource  ::</span> <span class="fu">!</span>a    <span class="co">-- ^ the whole text that was searched</span>
    ,<span class="ot"> capturedText   ::</span> <span class="fu">!</span>a    <span class="co">-- ^ the text that was matched</span>
    ,<span class="ot"> captureOffset  ::</span> <span class="fu">!</span><span class="dt">Int</span>  <span class="co">-- ^ the number of characters preceding the</span>
                              <span class="co">-- match with -1 used if no text was captured</span>
                              <span class="co">-- by the RE (not even the empty string)</span>
    ,<span class="ot"> captureLength  ::</span> <span class="fu">!</span><span class="dt">Int</span>  <span class="co">-- ^ the number of chacter in the captured</span>
                              <span class="co">-- sub-string</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)</code></pre></div>
</div>
<p>Here we list the whole original search string in <code>captureSource</code> and the text of the sub-string captured in <code>capturedText</code>. <code>captureOffset</code> contains the number of characters preceding the captured substring, or is negative if no substring was captured (which is a different situation from epsilon, the empty string, being captured). <code>captureLength</code> gives the length of the captured string in <code>capturedText</code>.</p>
<p>The test suite in <a href="re-tests.html">examples/re-tests.lhs</a> contains extensive worked-out examples of these <code>Matches</code>/<code>Match</code>/<code>Capture</code> types.</p>
<h2 id="using-functions-to-replace-text">Using Functions to Replace Text</h2>
Sometimes you will need to process each string captured by an RE with a function. <code>replaceAllCaptures</code> takes a <code>REContext</code>, a substitution function and a <code>Matches</code> and applies the function to each captured substring according to the <code>REContext</code>, as we can see in the following example function to clean up all of the mis-formatted dates in the argument string,
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fixup_dates ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
fixup_dates src <span class="fu">=</span>
    replaceAllCaptures <span class="dt">SUB</span> phi <span class="fu">$</span> src <span class="fu">*=~</span> [re<span class="fu">|</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">-</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">-</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">|</span>]
  <span class="kw">where</span>
    phi _ loc cap <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">case</span> locationCapture loc <span class="kw">of</span>
        <span class="dv">1</span> <span class="ot">-&gt;</span> fmt <span class="dv">4</span> <span class="fu">$</span> read s
        <span class="dv">2</span> <span class="ot">-&gt;</span> fmt <span class="dv">2</span> <span class="fu">$</span> read s
        <span class="dv">3</span> <span class="ot">-&gt;</span> fmt <span class="dv">2</span> <span class="fu">$</span> read s
        _ <span class="ot">-&gt;</span> error <span class="st">&quot;fixup_dates&quot;</span>
      <span class="kw">where</span>
        s <span class="fu">=</span> capturedText cap

<span class="ot">fmt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
fmt w x <span class="fu">=</span> replicate (max <span class="dv">0</span> <span class="fu">$</span> w <span class="fu">-</span> length x_s ) <span class="ch">&#39;0&#39;</span> <span class="fu">++</span> x_s
  <span class="kw">where</span>
    x_s <span class="fu">=</span> show x</code></pre></div>
which will fix up our running example
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> fixup_dates <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>
<span class="st">&quot;2016-01-09 2015-12-05 2015-10-05&quot;</span></code></pre></div>
<p>The <code>replaceAllCaptures</code> function is of type</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | substitutes using a function that takes the full Match</span>
<span class="co">-- context and returns the same replacement text as the _phi_phi</span>
<span class="co">-- context.</span>
<span class="ot">replaceAllCaptures ::</span> <span class="dt">Replace</span> a
                   <span class="ot">=&gt;</span> <span class="dt">REContext</span>
                   <span class="ot">-&gt;</span> (<span class="dt">Match</span> a<span class="ot">-&gt;</span><span class="dt">RELocation</span><span class="ot">-&gt;</span><span class="dt">Capture</span> a<span class="ot">-&gt;</span><span class="dt">Maybe</span> a)
                   <span class="ot">-&gt;</span> <span class="dt">Matches</span> a
                   <span class="ot">-&gt;</span> a</code></pre></div>
</div>
<p>and the <code>REContext</code> and <code>RELocation</code> types are defined in <code>Text.RE.Replace</code> as follows,</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | @REContext@ specifies which contexts the substitutions should be applied</span>
<span class="kw">data</span> <span class="dt">REContext</span>
  <span class="fu">=</span> <span class="dt">TOP</span>   <span class="co">-- ^ substitutions should be applied to the top-level only,</span>
          <span class="co">-- the text that matched the whole RE</span>
  <span class="fu">|</span> <span class="dt">SUB</span>   <span class="co">-- ^ substitutions should only be applied to the text</span>
          <span class="co">-- captured by bracketed sub-REs</span>
  <span class="fu">|</span> <span class="dt">ALL</span>   <span class="co">-- ^ the substitution function should be applied to all</span>
          <span class="co">-- captures, the top level and the sub-expression captures</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- | the @RELocation@ information passed into the substitution function</span>
<span class="co">-- specifies which sub-expression is being substituted</span>
<span class="kw">data</span> <span class="dt">RELocation</span> <span class="fu">=</span>
  <span class="dt">RELocation</span>
    {<span class="ot"> locationMatch   ::</span> <span class="dt">Int</span>
          <span class="co">-- ^ the zero-based, i-th string to be matched,</span>
          <span class="co">-- when matching all strings, zero when only the</span>
          <span class="co">-- first string is being matched</span>
    ,<span class="ot"> locationCapture ::</span> <span class="dt">CaptureOrdinal</span>
          <span class="co">-- ^ 0, when matching the top-level string</span>
          <span class="co">-- matched by the whole RE, 1 for the top-most,</span>
          <span class="co">-- left-most redex captured by bracketed</span>
          <span class="co">-- sub-REs, etc.</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
</div>
<p>The processing function gets applied to the captures specified by the <code>REContext</code>, which can be directed to process <code>ALL</code> of the captures, including the substring captured by the whole RE and all of the subsidiary capture, or just the <code>TOP</code>, <code>0</code> capture that the whole RE matches, or just the <code>SUB</code> (subsidiary) captures, as was the case above.</p>
<p>The substitution function takes the <code>Match</code> corresponding to the current redex being processed, the <code>RELocation</code> information specifying redex <em>n</em> redex and capure <em>i</em>, and the <code>Capure</code> being substituted. Our substitution function didn't need the <code>Match</code> context so it ignored it.</p>
<p>The substition function either return <code>Nothing</code> to indicate that no substitution should be made or the replacement text.</p>
The above fixup function could be extended to enclose whole date in square brackets by specifing an <code>ALL</code> context and a <code>0</code> case for the substitution function.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fixup_and_reformat_dates ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
fixup_and_reformat_dates src <span class="fu">=</span>
    replaceAllCaptures <span class="dt">ALL</span> f <span class="fu">$</span> src <span class="fu">*=~</span> [re<span class="fu">|</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">-</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">-</span>([<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]<span class="fu">+</span>)<span class="fu">|</span>]
  <span class="kw">where</span>
    f _ loc cap <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="kw">case</span> locationCapture loc <span class="kw">of</span>
        <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="st">&quot;[&quot;</span><span class="fu">++</span>txt<span class="fu">++</span><span class="st">&quot;]&quot;</span>
        <span class="dv">1</span> <span class="ot">-&gt;</span> fmt <span class="dv">4</span> <span class="fu">$</span> read txt
        <span class="dv">2</span> <span class="ot">-&gt;</span> fmt <span class="dv">2</span> <span class="fu">$</span> read txt
        <span class="dv">3</span> <span class="ot">-&gt;</span> fmt <span class="dv">2</span> <span class="fu">$</span> read txt
        _ <span class="ot">-&gt;</span> error <span class="st">&quot;fixup_date&quot;</span>
      <span class="kw">where</span>
        txt <span class="fu">=</span> capturedText cap</code></pre></div>
The <code>fixup_and_reformat_dates</code> applied to our running example,
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> fixup_and_reformat_dates <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>
<span class="st">&quot;[2016-01-09] [2015-12-05] [2015-10-05]&quot;</span></code></pre></div>
<p><code>Text.RE.Replace</code> provides analagous functions for replacing the test of a single <code>Match</code> returned from <code>?=~</code>.</p>
</div>    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-92650418-1', 'auto');
      ga('send', 'pageview');

    </script>
</body>
</html>
