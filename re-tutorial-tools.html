<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>regex â€“ re-tutorial-tools.lhs</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="lib/lhs-styles.css" />
  <link rel="stylesheet" href="lib/bs.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/>
  <link rel="manifest" href="/manifest.json"/>
  <link rel="mask-icon" href="/safari-pinned-tab.svg"/>
  <meta name="theme-color" content="#ffffff"/>
</head>
<body>
<div class='bcdiv'>
  <ol class='breadcrumb'>
    <li><a href="." style="font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;" id="branding">[<span style='color:red;'>re</span>|${<span style='color:red;'>gex</span>}(.*)|<span></span>]</a></li>
    <li><a title='source file' href='https://github.com/iconnect/regex/blob/master/examples/re-tutorial-tools.lhs'>re-tutorial-tools.lhs</a></li>
</ol>
</div>
<div class='litcontent'>
<header id="title-block-header">
<h1 class="title">re-tutorial-tools.lhs</h1>
</header>
<h1 id="the-regex-tools-tutorial">The Regex Tools Tutorial</h1>
<h2 id="language-options-and-imports">Language Options and Imports</h2>
<p>This tutorial is a literate Haskell program whwre we start by specifying the language pragmas and imports we will need for this module.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE QuasiQuotes                      #-}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span>               <span class="kw">as</span> <span class="dt">LBS</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.List</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Text.RE.Replace</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Text.RE.TDFA.String</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Text.RE.Tools</span></span></code></pre></div>
<h2 id="isregex-pcre-and-tdfa">IsRegex, PCRE and TDFA</h2>
<p>The <code>IsRegex re tx</code> provides regex methods for the RE type <code>re</code> (belonging to either the TDFA or PCRE back end) and a text type <code>tx</code> that the <code>re</code> back end accepts. The <code>Text.RE.TDFA</code> and <code>Text.RE.PCRE</code> API modules provide functions that work over all the text types, with the following match operators:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">(*=~)  ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>       <span class="ot">=&gt;</span> s</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>       <span class="ot">-&gt;</span> <span class="dt">RE</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>       <span class="ot">-&gt;</span> <span class="dt">Matches</span> s</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="ot">(?=~)  ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>       <span class="ot">=&gt;</span> s</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>       <span class="ot">-&gt;</span> <span class="dt">RE</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>       <span class="ot">-&gt;</span> <span class="dt">Match</span> s</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="ot">(*=~/) ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">SearchReplace</span> <span class="dt">RE</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a><span class="ot">(?=~/) ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">SearchReplace</span> <span class="dt">RE</span> s <span class="ot">-&gt;</span> s</span></code></pre></div>
<h2 id="general-isregex-functions">General IsRegex Functions</h2>
<p>The <code>IsRegex</code> class is located in <code>Text.RE.Tools.IsRegex</code>:</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">-- | the &#39;IsRegex&#39; class allows polymorhic tools to be written that</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="co">-- will work with a variety of regex back ends and text types</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Replace</span> s <span class="ot">=&gt;</span> <span class="dt">IsRegex</span> re s <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  <span class="co">-- | finding the first match</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="ot">  matchOnce             ::</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Match</span> s</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  <span class="co">-- | finding all matches</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="ot">  matchMany             ::</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Matches</span> s</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="co">-- | compiling an RE, failing if the RE is not well formed</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="ot">  makeRegex             ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> m re</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="co">-- | comiling an RE, specifying the &#39;SimpleREOptions&#39;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="ot">  makeRegexWith         ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  <span class="co">-- | compiling a &#39;SearchReplace&#39; template from the RE text and the template Text, failing if they are not well formed</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ot">  makeSearchReplace     ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m,<span class="dt">IsRegex</span> re s) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (<span class="dt">SearchReplace</span> re s)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  <span class="co">-- | compiling a &#39;SearchReplace&#39; template specifing the &#39;SimpleREOptions&#39; for the RE</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="ot">  makeSearchReplaceWith ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m,<span class="dt">IsRegex</span> re s) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (<span class="dt">SearchReplace</span> re s)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  <span class="co">-- | incorporate an escaped string into a compiled RE with the default options</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a><span class="ot">  makeEscaped           ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m) <span class="ot">=&gt;</span> (s<span class="ot">-&gt;</span>s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  <span class="co">-- | incorporate an escaped string into a compiled RE with the specified &#39;SimpleREOptions&#39;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="ot">  makeEscapedWith       ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m, <span class="dt">MonadFail</span> m) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> (s<span class="ot">-&gt;</span>s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  <span class="co">-- | extract the text of the RE from the RE</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ot">  regexSource           ::</span> re <span class="ot">-&gt;</span> s</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a>  makeRegex           <span class="ot">=</span> makeRegexWith         <span class="fu">minBound</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a>  makeSearchReplace   <span class="ot">=</span> makeSearchReplaceWith <span class="fu">minBound</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a>  makeEscaped         <span class="ot">=</span> makeEscapedWith       <span class="fu">minBound</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>  makeEscapedWith o f <span class="ot">=</span> makeRegexWith o <span class="op">.</span> f <span class="op">.</span> packR <span class="op">.</span> escapeREString <span class="op">.</span> unpackR</span></code></pre></div>
</div>
Using these functions you can write your own regex tools. As a trivial example we will define fully overloaded regex match operators as follows.
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">(?=~%) ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> <span class="dt">Match</span> s</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(<span class="op">?=~%</span>) <span class="ot">=</span> <span class="fu">flip</span> matchOnce</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ot">(*=~%) ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> <span class="dt">Matches</span> s</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>(<span class="op">*=~%</span>) <span class="ot">=</span> <span class="fu">flip</span> matchMany</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> matched <span class="op">$</span> (LBS.pack <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>) <span class="op">?=~%</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="dt">True</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> countMatches <span class="op">$</span> (LBS.pack <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>) <span class="op">*=~%</span> [re|[0-9]{4}-[0-9]{2}-[0-9]{2}|]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="dv">2</span></span></code></pre></div>
<p><code>regex</code> provides some classic tools that have quickly proven themselves in the examples and scripts used to maintain regex itself.</p>
<h2 id="the-regex-tools">The regex Tools</h2>
<p>The classic tools assocciated with regular expressions have inspired some regex conterparts.</p>
<ul>
<li><p><a href="Grep.html">Text.RE.Tools.Grep</a>: takes a regular expression and a file or lazy ByteString (depending upon the variant) and returns all of the matching lines.</p></li>
<li><p><a href="Lex.html">Text.RE.Tools.Lex</a>: takes an association list of REs and token-generating functions and the input text and returns a list of tokens. This should never be used where performance is important (use Alex), except as a development prototype.</p></li>
<li><p><a href="Sed.html">Text.RE.Tools.Sed</a> using <a href="Edit.html">Text.RE.Tools.Edit</a>: takes an association list of regular expressions and substitution actions, some input text and invokes the associated action on each line of the file that matches one of the REs, substituting the text returned from the action in the output stream.</p></li>
<li><p><a href="Find.html">Text.RE.Tools.Find</a>: scans a directory tree in the file system executing an action against all of the files that match RE.</p></li>
</ul>
<p>These tools are built on top of the core library and act as good examples of how to use the regex library as well as useful tools.</p>
<p>The following sections will present some of the internal library code used to build the tools as well as some code from the example programs. These fragments work best as starting points for studying these tools.</p>
<h2 id="sed-and-edit">Sed and Edit</h2>
<p><code>Edits</code> scripts are applied to each line of the text by the <code>sed</code> functions.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- | an &#39;Edits&#39; script will, for each line in the file, either perform</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="co">-- the action selected by the first RE in the list, or perform all of the</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="co">-- actions on line, arranged as a pipeline</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Edits</span> m re s</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Select</span> <span class="op">!</span>[<span class="dt">Edit</span> m re s]   <span class="co">-- ^ for each line select the first @Edit@ to match each line and edit the line with it</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Pipe</span>   <span class="op">!</span>[<span class="dt">Edit</span> m re s]   <span class="co">-- ^ for each line apply every edit that matches in turn to the line</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">-- | each Edit action specifies how the match should be processed</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Edit</span> m re s</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Template</span> <span class="op">!</span>(<span class="dt">SearchReplace</span> re s)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>        <span class="co">-- ^ replace the match with this template text, substituting ${capture} as apropriate</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Function</span> <span class="op">!</span>re <span class="dt">REContext</span> <span class="op">!</span>(<span class="dt">LineNo</span><span class="ot">-&gt;</span><span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">RELocation</span><span class="ot">-&gt;</span><span class="dt">Capture</span> s<span class="ot">-&gt;</span>m (<span class="dt">Maybe</span> s))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>        <span class="co">-- ^ use this function to replace the &#39;REContext&#39; specified captures in each line matched</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">LineEdit</span> <span class="op">!</span>re           <span class="op">!</span>(<span class="dt">LineNo</span><span class="ot">-&gt;</span><span class="dt">Matches</span> s<span class="ot">-&gt;</span>m (<span class="dt">LineEdit</span> s))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>        <span class="co">-- ^ use this function to edit each line matched</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="co">-- | a LineEdit is the most general action thar can be performed on a line</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="co">-- and is the only means of deleting a line</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">LineEdit</span> s</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">NoEdit</span>                  <span class="co">-- ^ do not edit this line but leave as is</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">ReplaceWith</span> <span class="op">!</span>s          <span class="co">-- ^ replace the line with this text (terminating newline should not be included)</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Delete</span>                  <span class="co">-- ^ delete the this line altogether</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p><code>sed'</code> applies the script in its first argument to each line in the text in its second argument.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">-- | apply an &#39;Edits&#39; script to each line of the argument text</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="ot">sed&#39; ::</span> (<span class="dt">IsRegex</span> re a,<span class="dt">Monad</span> m,<span class="dt">Functor</span> m)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>     <span class="ot">=&gt;</span> <span class="dt">Edits</span> m re a</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>     <span class="ot">-&gt;</span> a</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>     <span class="ot">-&gt;</span> m a</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>sed&#39; escr t <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  <span class="fu">mconcat</span> <span class="op">&lt;$&gt;</span> <span class="fu">sequence</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    [ applyEdits lno escr s</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>        <span class="op">|</span> (lno,s)<span class="ot">&lt;-</span><span class="fu">zip</span> [firstLine<span class="op">..</span>] <span class="op">$</span> linesR t</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>        ]</span></code></pre></div>
</div>
<p>The <code>sed'</code> function is used to build the include processor in the <a href="TestKit"><code>TestKit</code></a> utility modules used by the example scripts and programs. To filter lines to exclude the <code>grepFilter</code> function is used.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">-- | this function looks for lines of the form</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="co">--</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="co">--    `%include &lt;file&gt; [exclude &lt;RE&gt;]`</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co">--</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="co">-- and replaces them with the contents of the named file, optionally</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="co">-- excluding any lines that match the given RE.</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="ot">include ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">LBS.ByteString</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>include <span class="ot">=</span> sed&#39; <span class="op">$</span> <span class="dt">Select</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    [ <span class="dt">Function</span> [re|^%include ${file}(@{%string})$|]                              <span class="dt">TOP</span> incl</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>    , <span class="dt">Function</span> [re|^%include ${file}(@{%string}) *exclude *${rex}(@{%string})$|] <span class="dt">TOP</span> incl</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    , <span class="dt">Function</span> [re|^.*$|]                                                        <span class="dt">TOP</span> nop</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    ]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    incl _ mtch _ _ <span class="ot">=</span> include&#39; mtch</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    nop  _ _    _ _ <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a><span class="co">-- | processes the match from a &#39;%include&#39; line, analyses the match,</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a><span class="co">-- fetches the file, optionally excludes lines specified by an RE,</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a><span class="co">-- returning the text to include.</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a><span class="ot">include&#39; ::</span> <span class="dt">Match</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">LBS.ByteString</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a>include&#39; mtch <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a>    ftr <span class="ot">&lt;-</span> <span class="kw">case</span> prs_s <span class="op">&lt;$&gt;</span> mtch <span class="op">!$$?</span> [cp|rex|] <span class="kw">of</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true"></a>      <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="fu">id</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true"></a>      <span class="dt">Just</span> re_lbs <span class="ot">-&gt;</span> excl <span class="op">&lt;$&gt;</span> makeRegex re_lbs</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true"></a>    <span class="dt">Just</span> <span class="op">.</span> ftr <span class="op">&lt;$&gt;</span> LBS.readFile (prs_s <span class="op">$</span> mtch <span class="op">!$$</span> [cp|file|])</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true"></a><span class="ot">    excl ::</span> <span class="dt">RE</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true"></a>    excl rex <span class="ot">=</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true"></a>        LBS.unlines <span class="op">.</span> <span class="fu">map</span> (matchesSource <span class="op">.</span> getLineMatches)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true"></a>          <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> anyMatches <span class="op">.</span> getLineMatches)</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true"></a>          <span class="op">.</span> grepFilter rex</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true"></a>    prs_s  <span class="ot">=</span> <span class="fu">maybe</span> (<span class="fu">error</span> <span class="st">&quot;include&#39;&quot;</span>) T.unpack <span class="op">.</span> parseString</span></code></pre></div>
</div>
<h2 id="grep">Grep</h2>
<p>The <code>grepFilter</code> function takes an RE and a text and returns the result of matching the RE to every line in the file.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- | returns a &#39;Line&#39; for each line in the argument text, enumerating</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">-- all of the matches for that line</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="ot">grepFilter ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [<span class="dt">Line</span> s]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>grepFilter rex <span class="ot">=</span> grepWithScript [(rex,mk)] <span class="op">.</span> linesR</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    mk i mtchs <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> <span class="dt">Line</span> i mtchs</span></code></pre></div>
</div>
<div class="includedcodeblock">
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- | &#39;grepLines&#39; returns a &#39;Line&#39; for each line in the file, listing all</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="co">-- of the &#39;Matches&#39; for that line</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Line</span> s <span class="ot">=</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Line</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    {<span class="ot"> getLineNumber  ::</span> <span class="dt">LineNo</span>    <span class="co">-- ^ the &#39;LineNo&#39; for this line</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    ,<span class="ot"> getLineMatches ::</span> <span class="dt">Matches</span> s <span class="co">-- ^ all the &#39;Matches&#39; of the RE on this line</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    }</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>The <code>sortImports</code> utility in the <a href="TestKit"><code>TestKit</code></a> utility module used by the scripts and example programs. It uses <code>grep</code> to sort all of the imports by the name of the module in a single block located at the position of the first import statement in the module, where each import statement is in a standard form matched by the regex</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>[re|^import +(qualified|         ) ${mod}([^ ].*)$|]</span></code></pre></div>
We have reproduced <code>sortImports</code> under the name <code>sortImports_</code> here.
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">sortImports_ ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>sortImports_ lbs <span class="ot">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    LBS.unlines <span class="op">$</span> <span class="fu">map</span> (matchesSource <span class="op">.</span> getLineMatches) <span class="op">$</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>      hdr <span class="op">++</span> sortBy cMp bdy</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>    cMp ln1 ln2 <span class="ot">=</span> <span class="kw">case</span> (extr ln1,extr ln2) <span class="kw">of</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>        (<span class="dt">Nothing</span>,<span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="dt">EQ</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>        (<span class="dt">Nothing</span>,<span class="dt">Just</span> _ ) <span class="ot">-&gt;</span> <span class="dt">GT</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>        (<span class="dt">Just</span> _ ,<span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="dt">LT</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>        (<span class="dt">Just</span> x ,<span class="dt">Just</span>  y) <span class="ot">-&gt;</span> <span class="fu">compare</span> x y</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>    extr ln <span class="ot">=</span> <span class="kw">case</span> allMatches <span class="op">$</span> getLineMatches ln <span class="kw">of</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>      mtch<span class="op">:</span>_  <span class="ot">-&gt;</span> mtch <span class="op">!$$?</span> [cp|mod|]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>      _       <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>    (hdr,bdy) <span class="ot">=</span> <span class="fu">span</span> (<span class="fu">not</span> <span class="op">.</span> anyMatches <span class="op">.</span> getLineMatches) lns</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>    lns       <span class="ot">=</span> grepFilter rex lbs</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>    rex       <span class="ot">=</span> [re|^import +(qualified )? *${mod}([^ ].*)$|]</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> sortImports_ <span class="op">$</span> LBS.pack <span class="st">&quot;-- preamble\nimport qualified Data.Text as T\nimport Data.List\n-- done\n&quot;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="st">&quot;-- preamble\nimport Data.List\nimport qualified Data.Text as T\n-- done\n&quot;</span></span></code></pre></div>
<h2 id="lex">Lex</h2>
<p>The Lex toolkit can be used for quickly knocking together scanners that do not need to be efficient.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">-- | a simple regex-based scanner interpretter for prototyping</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="co">-- scanners</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="ot">alex ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> [(re,<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Maybe</span> t)] <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [t]</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>alex <span class="ot">=</span> alex&#39; matchOnce</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="co">-- | a higher order version of &#39;alex&#39; parameterised over the @matchOnce@</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span class="co">-- function</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a><span class="ot">alex&#39; ::</span> <span class="dt">Replace</span> s</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>      <span class="ot">=&gt;</span> (re<span class="ot">-&gt;</span>s<span class="ot">-&gt;</span><span class="dt">Match</span> s)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>      <span class="ot">-&gt;</span> [(re,<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Maybe</span> t)]</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>      <span class="ot">-&gt;</span> t</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>      <span class="ot">-&gt;</span> s</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>      <span class="ot">-&gt;</span> [t]</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>alex&#39; mo al t_err <span class="ot">=</span> loop</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>    loop s <span class="ot">=</span> <span class="kw">case</span> lengthR s <span class="op">==</span> <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>      <span class="dt">True</span>  <span class="ot">-&gt;</span> []</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>      <span class="dt">False</span> <span class="ot">-&gt;</span> choose al s</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>    choose []           _ <span class="ot">=</span> [t_err]</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>    choose ((re,f)<span class="op">:</span>al&#39;) s <span class="ot">=</span> <span class="kw">case</span> mb_p <span class="kw">of</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>        <span class="dt">Just</span> (s&#39;,t) <span class="ot">-&gt;</span> t <span class="op">:</span> loop s&#39;</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>        _           <span class="ot">-&gt;</span> choose al&#39; s</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true"></a>      <span class="kw">where</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true"></a>        mb_p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true"></a>          cap <span class="ot">&lt;-</span> matchCapture mtch</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true"></a>          <span class="kw">case</span> captureOffset cap <span class="op">==</span> <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true"></a>            <span class="dt">True</span>  <span class="ot">-&gt;</span> (,) (captureSuffix cap) <span class="op">&lt;$&gt;</span> f mtch</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true"></a>            <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true"></a></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true"></a>        mtch <span class="ot">=</span> mo re s</span></code></pre></div>
</div>
<p>It has been used in the library to scan REs so that the captures can be picked out, numbered and that number associated with a name where one has been given.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="co">-- | scan a RE string into a list of RE Token</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="ot">scan ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>scan <span class="ot">=</span> alex&#39; match al <span class="op">$</span> oops <span class="st">&quot;top&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ot">    al ::</span> [(<span class="dt">Regex</span>,<span class="dt">Match</span> <span class="dt">String</span><span class="ot">-&gt;</span><span class="dt">Maybe</span> <span class="dt">Token</span>)]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    al <span class="ot">=</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>      [ mk <span class="st">&quot;\\$\\{([^{}]+)\\}\\(&quot;</span> <span class="op">$</span>         <span class="dt">ECap</span> <span class="op">.</span> <span class="dt">Just</span> <span class="op">.</span> x_1</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>      , mk <span class="st">&quot;\\$\\(&quot;</span>               <span class="op">$</span> <span class="fu">const</span> <span class="op">$</span> <span class="dt">ECap</span> <span class="dt">Nothing</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>      , mk <span class="st">&quot;\\(\\?:&quot;</span>              <span class="op">$</span> <span class="fu">const</span>   <span class="dt">PGrp</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>      , mk <span class="st">&quot;\\(\\?&quot;</span>               <span class="op">$</span> <span class="fu">const</span>   <span class="dt">PCap</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>      , mk <span class="st">&quot;\\(&quot;</span>                  <span class="op">$</span> <span class="fu">const</span>   <span class="dt">Bra</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>      , mk <span class="st">&quot;\\\\(.)&quot;</span>              <span class="op">$</span>         <span class="dt">BS</span>    <span class="op">.</span> s2c <span class="op">.</span> x_1</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>      , mk <span class="st">&quot;(.|\n)&quot;</span>               <span class="op">$</span>         <span class="dt">Other</span> <span class="op">.</span> s2c <span class="op">.</span> x_1</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>      ]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>    x_1     <span class="ot">=</span> captureText <span class="op">$</span> <span class="dt">IsCaptureOrdinal</span> <span class="op">$</span> <span class="dt">CaptureOrdinal</span> <span class="dv">1</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>    s2c [c] <span class="ot">=</span> c</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>    s2c _   <span class="ot">=</span> oops <span class="st">&quot;s2c&quot;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>    mk s f  <span class="ot">=</span> (poss <span class="fu">error</span> <span class="fu">id</span> <span class="op">$</span> makeRegexM s,<span class="dt">Just</span> <span class="op">.</span> f)</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a>    oops  m <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;NamedCaptures.scan: &quot;</span> <span class="op">++</span> m</span></code></pre></div>
</div>
<h2 id="find">Find</h2>
<p>The <code>findMatches_</code> function lists all of the files in a directort tree that match an RE.</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">-- | recursively list all files whose filename matches given RE,</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="co">-- sorting the list into ascending order; if the argument path has a</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="co">-- trailing &#39;/&#39; then it will be removed</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="ot">findMatches_ ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>findMatches_ fm <span class="ot">=</span> findMatches_&#39; fm L.sort matched</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="co">-- | recursively list all files whose filename matches given RE,</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="co">-- using the given function to determine which matches to accept</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="ot">findMatches_&#39; ::</span> <span class="dt">IsRegex</span> re s</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>              <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s         <span class="co">-- ^ the directory and filepath methods</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>              <span class="ot">-&gt;</span> ([s]<span class="ot">-&gt;</span>[s])            <span class="co">-- ^ result post-processing function</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>              <span class="ot">-&gt;</span> (<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Bool</span>)       <span class="co">-- ^ filtering function</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>              <span class="ot">-&gt;</span> re                    <span class="co">-- ^ re to be matched against the leaf filename</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>              <span class="ot">-&gt;</span> s                     <span class="co">-- ^ root directory of the search</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>              <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>findMatches_&#39; fm srt tst re fp <span class="ot">=</span> srt <span class="op">&lt;$&gt;</span> find_ fm tst re (packR <span class="st">&quot;&quot;</span>) fp</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a><span class="ot">find_ ::</span> <span class="dt">IsRegex</span> re s</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>      <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>      <span class="ot">-&gt;</span> (<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Bool</span>)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>      <span class="ot">-&gt;</span> re</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>      <span class="ot">-&gt;</span> s</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>      <span class="ot">-&gt;</span> s</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>      <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>find_ fm<span class="op">@</span><span class="dt">FindMethods</span>{<span class="op">..</span>} tst re fn fp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>  is_dir <span class="ot">&lt;-</span> doesDirectoryExistDM fp</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>  <span class="kw">case</span> is_dir <span class="kw">of</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>    <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true"></a>      fns <span class="ot">&lt;-</span> <span class="fu">filter</span> ordinary <span class="op">&lt;$&gt;</span> listDirectoryDM fp</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true"></a>      <span class="fu">concat</span> <span class="op">&lt;$&gt;</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true"></a>        <span class="fu">mapM</span> (<span class="fu">uncurry</span> <span class="op">$</span> find_ fm tst re) [ (fn_,abs_path fn_) <span class="op">|</span> fn_<span class="ot">&lt;-</span>fns ]</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="fu">return</span> [ fp <span class="op">|</span> lengthR fp <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> tst (matchOnce re fn) ]</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true"></a>    abs_path fn_ <span class="ot">=</span> fp <span class="ot">`combineDM`</span> fn_</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true"></a>    ordinary fn_ <span class="ot">=</span> <span class="fu">not</span> <span class="op">$</span> fn_ <span class="ot">`elem`</span> [packR <span class="st">&quot;.&quot;</span>,packR <span class="st">&quot;..&quot;</span>]</span></code></pre></div>
</div>
<p>It is used by the <a href="re-sort-imports"><code>re-sort-imports</code></a> program to discover all of the Haskell scripts in the regex source tree and sort their import statements into a standard order (ultimately using the above-mentioned <code>sortImport</code> function).</p>
<div class="includedcodeblock">
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">sort_r ::</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>sort_r md root <span class="ot">=</span> findMatches_ fm [re|\.l?hs|] root <span class="op">&gt;&gt;=</span> sort_these md root</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    fm <span class="ot">=</span> <span class="dt">FindMethods</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>      { doesDirectoryExistDM <span class="ot">=</span> doesDirectoryExist</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>      , listDirectoryDM      <span class="ot">=</span> getDirectoryContents</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>      , combineDM            <span class="ot">=</span> (<span class="op">&lt;/&gt;</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>      }</span></code></pre></div>
</div>
</div>    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-92650418-1', 'auto');
      ga('send', 'pageview');

    </script>
</body>
</html>
