<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>regex â€“ re-tutorial-tools.lhs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="lib/lhs-styles.css">
  <link rel="stylesheet" href="lib/bs.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/>
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/>
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/>
  <link rel="manifest" href="/manifest.json"/>
  <link rel="mask-icon" href="/safari-pinned-tab.svg"/>
  <meta name="theme-color" content="#ffffff"/>
</head>
<body>
<div class='bcdiv'>
  <ol class='breadcrumb'>
    <li><a href="." style="font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;" id="branding">[<span style='color:red;'>re</span>|${<span style='color:red;'>gex</span>}(.*)|<span></span>]</a></li>
    <li><a title='source file' href='https://github.com/iconnect/regex/blob/master/examples/re-tutorial-tools.lhs'>re-tutorial-tools.lhs</a></li>
</ol>
</div>
<div class='litcontent'>
<header>
<h1 class="title">re-tutorial-tools.lhs</h1>
</header>
<h1 id="the-regex-tools-tutorial">The Regex Tools Tutorial</h1>
<h2 id="language-options-and-imports">Language Options and Imports</h2>
<p>This tutorial is a literate Haskell program whwre we start by specifying the language pragmas and imports we will need for this module.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes                      #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span>               <span class="kw">as</span> <span class="dt">LBS</span>
<span class="kw">import           </span><span class="dt">Data.List</span>
<span class="kw">import           </span><span class="dt">Text.RE.Replace</span>
<span class="kw">import           </span><span class="dt">Text.RE.TDFA.String</span>
<span class="kw">import           </span><span class="dt">Text.RE.Tools</span></code></pre></div>
<h2 id="isregex-pcre-and-tdfa">IsRegex, PCRE and TDFA</h2>
<p>The <code>IsRegex re tx</code> provides regex methods for the RE type <code>re</code> (belonging to either the TDFA or PCRE back end) and a text type <code>tx</code> that the <code>re</code> back end accepts. The <code>Text.RE.TDFA</code> and <code>Text.RE.PCRE</code> API modules provide functions that work over all the text types, with the following match operators:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(*=~)  ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s
       <span class="ot">=&gt;</span> s
       <span class="ot">-&gt;</span> <span class="dt">RE</span>
       <span class="ot">-&gt;</span> <span class="dt">Matches</span> s

<span class="ot">(?=~)  ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s
       <span class="ot">=&gt;</span> s
       <span class="ot">-&gt;</span> <span class="dt">RE</span>
       <span class="ot">-&gt;</span> <span class="dt">Match</span> s

<span class="ot">(*=~/) ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">SearchReplace</span> <span class="dt">RE</span> s <span class="ot">-&gt;</span> s

<span class="ot">(?=~/) ::</span> <span class="dt">IsRegex</span> <span class="dt">RE</span> s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">SearchReplace</span> <span class="dt">RE</span> s <span class="ot">-&gt;</span> s</code></pre></div>
<h2 id="general-isregex-functions">General IsRegex Functions</h2>
<p>The <code>IsRegex</code> class is located in <code>Text.RE.Tools.IsRegex</code>:</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | the &#39;IsRegex&#39; class allows polymorhic tools to be written that</span>
<span class="co">-- will work with a variety of regex back ends and text types</span>
<span class="kw">class</span> <span class="dt">Replace</span> s <span class="ot">=&gt;</span> <span class="dt">IsRegex</span> re s <span class="kw">where</span>
  <span class="co">-- | finding the first match</span>
<span class="ot">  matchOnce             ::</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Match</span> s
  <span class="co">-- | finding all matches</span>
<span class="ot">  matchMany             ::</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Matches</span> s
  <span class="co">-- | compiling an RE, failing if the RE is not well formed</span>
<span class="ot">  makeRegex             ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> m re
  <span class="co">-- | comiling an RE, specifying the &#39;SimpleREOptions&#39;</span>
<span class="ot">  makeRegexWith         ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re
  <span class="co">-- | compiling a &#39;SearchReplace&#39; template from the RE text and the template Text, failing if they are not well formed</span>
<span class="ot">  makeSearchReplace     ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m,<span class="dt">IsRegex</span> re s) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (<span class="dt">SearchReplace</span> re s)
  <span class="co">-- | compiling a &#39;SearchReplace&#39; template specifing the &#39;SimpleREOptions&#39; for the RE</span>
<span class="ot">  makeSearchReplaceWith ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m,<span class="dt">IsRegex</span> re s) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m (<span class="dt">SearchReplace</span> re s)
  <span class="co">-- | incorporate an escaped string into a compiled RE with the default options</span>
<span class="ot">  makeEscaped           ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (s<span class="ot">-&gt;</span>s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re
  <span class="co">-- | incorporate an escaped string into a compiled RE with the specified &#39;SimpleREOptions&#39;</span>
<span class="ot">  makeEscapedWith       ::</span> (<span class="dt">Functor</span> m,<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">SimpleREOptions</span> <span class="ot">-&gt;</span> (s<span class="ot">-&gt;</span>s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m re
  <span class="co">-- | extract the text of the RE from the RE</span>
<span class="ot">  regexSource           ::</span> re <span class="ot">-&gt;</span> s

  makeRegex           <span class="fu">=</span> makeRegexWith         minBound
  makeSearchReplace   <span class="fu">=</span> makeSearchReplaceWith minBound
  makeEscaped         <span class="fu">=</span> makeEscapedWith       minBound
  makeEscapedWith o f <span class="fu">=</span> makeRegexWith o <span class="fu">.</span> f <span class="fu">.</span> packR <span class="fu">.</span> escapeREString <span class="fu">.</span> unpackR</code></pre></div>
</div>
Using these functions you can write your own regex tools. As a trivial example we will define fully overloaded regex match operators as follows.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">(?=~%) ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> <span class="dt">Match</span> s
(<span class="fu">?=~%</span>) <span class="fu">=</span> flip matchOnce

<span class="ot">(*=~%) ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> <span class="dt">Matches</span> s
(<span class="fu">*=~%</span>) <span class="fu">=</span> flip matchMany</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> matched <span class="fu">$</span> (LBS.pack <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>) <span class="fu">?=~%</span> [re<span class="fu">|</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">4</span>}<span class="fu">-</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>}<span class="fu">-</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>}<span class="fu">|</span>]
<span class="dt">True</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> countMatches <span class="fu">$</span> (LBS.pack <span class="st">&quot;2016-01-09 2015-12-5 2015-10-05&quot;</span>) <span class="fu">*=~%</span> [re<span class="fu">|</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">4</span>}<span class="fu">-</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>}<span class="fu">-</span>[<span class="dv">0</span><span class="fu">-</span><span class="dv">9</span>]{<span class="dv">2</span>}<span class="fu">|</span>]
<span class="dv">2</span></code></pre></div>
<p><code>regex</code> provides some classic tools that have quickly proven themselves in the examples and scripts used to maintain regex itself.</p>
<h2 id="the-regex-tools">The regex Tools</h2>
<p>The classic tools assocciated with regular expressions have inspired some regex conterparts.</p>
<ul>
<li><p><a href="Grep.html">Text.RE.Tools.Grep</a>: takes a regular expression and a file or lazy ByteString (depending upon the variant) and returns all of the matching lines.</p></li>
<li><p><a href="Lex.html">Text.RE.Tools.Lex</a>: takes an association list of REs and token-generating functions and the input text and returns a list of tokens. This should never be used where performance is important (use Alex), except as a development prototype.</p></li>
<li><p><a href="Sed.html">Text.RE.Tools.Sed</a> using <a href="Edit.html">Text.RE.Tools.Edit</a>: takes an association list of regular expressions and substitution actions, some input text and invokes the associated action on each line of the file that matches one of the REs, substituting the text returned from the action in the output stream.</p></li>
<li><p><a href="Find.html">Text.RE.Tools.Find</a>: scans a directory tree in the file system executing an action against all of the files that match RE.</p></li>
</ul>
<p>These tools are built on top of the core library and act as good examples of how to use the regex library as well as useful tools.</p>
<p>The following sections will present some of the internal library code used to build the tools as well as some code from the example programs. These fragments work best as starting points for studying these tools.</p>
<h2 id="sed-and-edit">Sed and Edit</h2>
<p><code>Edits</code> scripts are applied to each line of the text by the <code>sed</code> functions.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | an &#39;Edits&#39; script will, for each line in the file, either perform</span>
<span class="co">-- the action selected by the first RE in the list, or perform all of the</span>
<span class="co">-- actions on line, arranged as a pipeline</span>
<span class="kw">data</span> <span class="dt">Edits</span> m re s
  <span class="fu">=</span> <span class="dt">Select</span> <span class="fu">!</span>[<span class="dt">Edit</span> m re s]   <span class="co">-- ^ for each line select the first @Edit@ to match each line and edit the line with it</span>
  <span class="fu">|</span> <span class="dt">Pipe</span>   <span class="fu">!</span>[<span class="dt">Edit</span> m re s]   <span class="co">-- ^ for each line apply every edit that matches in turn to the line</span>

<span class="co">-- | each Edit action specifies how the match should be processed</span>
<span class="kw">data</span> <span class="dt">Edit</span> m re s
  <span class="fu">=</span> <span class="dt">Template</span> <span class="fu">!</span>(<span class="dt">SearchReplace</span> re s)
        <span class="co">-- ^ replace the match with this template text, substituting ${capture} as apropriate</span>
  <span class="fu">|</span> <span class="dt">Function</span> <span class="fu">!</span>re <span class="dt">REContext</span> <span class="fu">!</span>(<span class="dt">LineNo</span><span class="ot">-&gt;</span><span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">RELocation</span><span class="ot">-&gt;</span><span class="dt">Capture</span> s<span class="ot">-&gt;</span>m (<span class="dt">Maybe</span> s))
        <span class="co">-- ^ use this function to replace the &#39;REContext&#39; specified captures in each line matched</span>
  <span class="fu">|</span> <span class="dt">LineEdit</span> <span class="fu">!</span>re           <span class="fu">!</span>(<span class="dt">LineNo</span><span class="ot">-&gt;</span><span class="dt">Matches</span> s<span class="ot">-&gt;</span>m (<span class="dt">LineEdit</span> s))
        <span class="co">-- ^ use this function to edit each line matched</span>

<span class="co">-- | a LineEdit is the most general action thar can be performed on a line</span>
<span class="co">-- and is the only means of deleting a line</span>
<span class="kw">data</span> <span class="dt">LineEdit</span> s
  <span class="fu">=</span> <span class="dt">NoEdit</span>                  <span class="co">-- ^ do not edit this line but leave as is</span>
  <span class="fu">|</span> <span class="dt">ReplaceWith</span> <span class="fu">!</span>s          <span class="co">-- ^ replace the line with this text (terminating newline should not be included)</span>
  <span class="fu">|</span> <span class="dt">Delete</span>                  <span class="co">-- ^ delete the this line altogether</span>
  <span class="kw">deriving</span> (<span class="dt">Functor</span>,<span class="dt">Show</span>)</code></pre></div>
</div>
<p><code>sed'</code> applies the script in its first argument to each line in the text in its second argument.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | apply an &#39;Edits&#39; script to each line of the argument text</span>
<span class="ot">sed&#39; ::</span> (<span class="dt">IsRegex</span> re a,<span class="dt">Monad</span> m,<span class="dt">Functor</span> m)
     <span class="ot">=&gt;</span> <span class="dt">Edits</span> m re a
     <span class="ot">-&gt;</span> a
     <span class="ot">-&gt;</span> m a
sed&#39; escr t <span class="fu">=</span> <span class="kw">do</span>
  mconcat <span class="fu">&lt;$&gt;</span> sequence
    [ applyEdits lno escr s
        <span class="fu">|</span> (lno,s)<span class="ot">&lt;-</span>zip [firstLine<span class="fu">..</span>] <span class="fu">$</span> linesR t
        ]</code></pre></div>
</div>
<p>The <code>sed'</code> function is used to build the include processor in the <a href="TestKit"><code>TestKit</code></a> utility modules used by the example scripts and programs. To filter lines to exclude the <code>grepFilter</code> function is used.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | this function looks for lines of the form</span>
<span class="fu">--</span>
<span class="co">--    `%include &lt;file&gt; [exclude &lt;RE&gt;]`</span>
<span class="fu">--</span>
<span class="co">-- and replaces them with the contents of the named file, optionally</span>
<span class="co">-- excluding any lines that match the given RE.</span>
<span class="ot">include ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">LBS.ByteString</span>
include <span class="fu">=</span> sed&#39; <span class="fu">$</span> <span class="dt">Select</span>
    [ <span class="dt">Function</span> [re<span class="fu">|^%</span>include <span class="fu">$</span>{file}(<span class="fu">@</span>{<span class="fu">%</span>string})<span class="fu">$|</span>]                              <span class="dt">TOP</span> incl
    , <span class="dt">Function</span> [re<span class="fu">|^%</span>include <span class="fu">$</span>{file}(<span class="fu">@</span>{<span class="fu">%</span>string}) <span class="fu">*</span>exclude <span class="fu">*$</span>{rex}(<span class="fu">@</span>{<span class="fu">%</span>string})<span class="fu">$|</span>] <span class="dt">TOP</span> incl
    , <span class="dt">Function</span> [re<span class="fu">|^.*$|</span>]                                                        <span class="dt">TOP</span> nop
    ]
  <span class="kw">where</span>
    incl _ mtch _ _ <span class="fu">=</span> include&#39; mtch
    nop  _ _    _ _ <span class="fu">=</span> return <span class="dt">Nothing</span>

<span class="co">-- | processes the match from a &#39;%include&#39; line, analyses the match,</span>
<span class="co">-- fetches the file, optionally excludes lines specified by an RE,</span>
<span class="co">-- returning the text to include.</span>
<span class="ot">include&#39; ::</span> <span class="dt">Match</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">LBS.ByteString</span>)
include&#39; mtch <span class="fu">=</span> <span class="kw">do</span>
    ftr <span class="ot">&lt;-</span> <span class="kw">case</span> prs_s <span class="fu">&lt;$&gt;</span> mtch <span class="fu">!$$?</span> [cp<span class="fu">|</span>rex<span class="fu">|</span>] <span class="kw">of</span>
      <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> return id
      <span class="dt">Just</span> re_lbs <span class="ot">-&gt;</span> excl <span class="fu">&lt;$&gt;</span> makeRegex re_lbs
    <span class="dt">Just</span> <span class="fu">.</span> ftr <span class="fu">&lt;$&gt;</span> LBS.readFile (prs_s <span class="fu">$</span> mtch <span class="fu">!$$</span> [cp<span class="fu">|</span>file<span class="fu">|</span>])
  <span class="kw">where</span>
<span class="ot">    excl ::</span> <span class="dt">RE</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span>
    excl rex <span class="fu">=</span>
        LBS.unlines <span class="fu">.</span> map (matchesSource <span class="fu">.</span> getLineMatches)
          <span class="fu">.</span> filter (not <span class="fu">.</span> anyMatches <span class="fu">.</span> getLineMatches)
          <span class="fu">.</span> grepFilter rex

    prs_s  <span class="fu">=</span> maybe (error <span class="st">&quot;include&#39;&quot;</span>) T.unpack <span class="fu">.</span> parseString</code></pre></div>
</div>
<h2 id="grep">Grep</h2>
<p>The <code>grepFilter</code> function takes an RE and a text and returns the result of matching the RE to every line in the file.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | returns a &#39;Line&#39; for each line in the argument text, enumerating</span>
<span class="co">-- all of the matches for that line</span>
<span class="ot">grepFilter ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [<span class="dt">Line</span> s]
grepFilter rex <span class="fu">=</span> grepWithScript [(rex,mk)] <span class="fu">.</span> linesR
  <span class="kw">where</span>
    mk i mtchs <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Line</span> i mtchs</code></pre></div>
</div>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | &#39;grepLines&#39; returns a &#39;Line&#39; for each line in the file, listing all</span>
<span class="co">-- of the &#39;Matches&#39; for that line</span>
<span class="kw">data</span> <span class="dt">Line</span> s <span class="fu">=</span>
  <span class="dt">Line</span>
    {<span class="ot"> getLineNumber  ::</span> <span class="dt">LineNo</span>    <span class="co">-- ^ the &#39;LineNo&#39; for this line</span>
    ,<span class="ot"> getLineMatches ::</span> <span class="dt">Matches</span> s <span class="co">-- ^ all the &#39;Matches&#39; of the RE on this line</span>
    }
  <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
</div>
<p>The <code>sortImports</code> utility in the <a href="TestKit"><code>TestKit</code></a> utility module used by the scripts and example programs. It uses <code>grep</code> to sort all of the imports by the name of the module in a single block located at the position of the first import statement in the module, where each import statement is in a standard form matched by the regex</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">[re<span class="fu">|^</span><span class="kw">import </span>+(<span class="kw">qualified</span> )? *${mod}([^ ].*)$|]</code></pre></div>
We have reproduced <code>sortImports</code> under the name <code>sortImports_</code> here.
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sortImports_ ::</span> <span class="dt">LBS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">LBS.ByteString</span>
sortImports_ lbs <span class="fu">=</span>
    LBS.unlines <span class="fu">$</span> map (matchesSource <span class="fu">.</span> getLineMatches) <span class="fu">$</span>
      hdr <span class="fu">++</span> sortBy cMp bdy
  <span class="kw">where</span>
    cMp ln1 ln2 <span class="fu">=</span> <span class="kw">case</span> (extr ln1,extr ln2) <span class="kw">of</span>
        (<span class="dt">Nothing</span>,<span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="dt">EQ</span>
        (<span class="dt">Nothing</span>,<span class="dt">Just</span> _ ) <span class="ot">-&gt;</span> <span class="dt">GT</span>
        (<span class="dt">Just</span> _ ,<span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="dt">LT</span>
        (<span class="dt">Just</span> x ,<span class="dt">Just</span>  y) <span class="ot">-&gt;</span> compare x y

    extr ln <span class="fu">=</span> <span class="kw">case</span> allMatches <span class="fu">$</span> getLineMatches ln <span class="kw">of</span>
      mtch<span class="fu">:</span>_  <span class="ot">-&gt;</span> mtch <span class="fu">!$$?</span> [cp<span class="fu">|</span>mod<span class="fu">|</span>]
      _       <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

    (hdr,bdy) <span class="fu">=</span> span (not <span class="fu">.</span> anyMatches <span class="fu">.</span> getLineMatches) lns
    lns       <span class="fu">=</span> grepFilter rex lbs
    rex       <span class="fu">=</span> [re<span class="fu">|^</span><span class="kw">import </span>+(<span class="kw">qualified</span> )? *${mod}([^ ].*)$|]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> sortImports_ <span class="fu">$</span> LBS.pack <span class="st">&quot;-- preamble\nimport qualified Data.Text as T\nimport Data.List\n-- done\n&quot;</span>
<span class="st">&quot;-- preamble\nimport Data.List\nimport qualified Data.Text as T\n-- done\n&quot;</span></code></pre></div>
<h2 id="lex">Lex</h2>
<p>The Lex toolkit can be used for quickly knocking together scanners that do not need to be efficient.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | a simple regex-based scanner interpretter for prototyping</span>
<span class="co">-- scanners</span>
<span class="ot">alex ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> [(re,<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Maybe</span> t)] <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [t]
alex <span class="fu">=</span> alex&#39; matchOnce

<span class="co">-- | a higher order version of &#39;alex&#39; parameterised over the @matchOnce@</span>
<span class="co">-- function</span>
<span class="ot">alex&#39; ::</span> <span class="dt">Replace</span> s
      <span class="ot">=&gt;</span> (re<span class="ot">-&gt;</span>s<span class="ot">-&gt;</span><span class="dt">Match</span> s)
      <span class="ot">-&gt;</span> [(re,<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Maybe</span> t)]
      <span class="ot">-&gt;</span> t
      <span class="ot">-&gt;</span> s
      <span class="ot">-&gt;</span> [t]
alex&#39; mo al t_err <span class="fu">=</span> loop
  <span class="kw">where</span>
    loop s <span class="fu">=</span> <span class="kw">case</span> lengthR s <span class="fu">==</span> <span class="dv">0</span> <span class="kw">of</span>
      <span class="dt">True</span>  <span class="ot">-&gt;</span> []
      <span class="dt">False</span> <span class="ot">-&gt;</span> choose al s

    choose []           _ <span class="fu">=</span> [t_err]
    choose ((re,f)<span class="fu">:</span>al&#39;) s <span class="fu">=</span> <span class="kw">case</span> mb_p <span class="kw">of</span>
        <span class="dt">Just</span> (s&#39;,t) <span class="ot">-&gt;</span> t <span class="fu">:</span> loop s&#39;
        _           <span class="ot">-&gt;</span> choose al&#39; s
      <span class="kw">where</span>
        mb_p <span class="fu">=</span> <span class="kw">do</span>
          cap <span class="ot">&lt;-</span> matchCapture mtch
          <span class="kw">case</span> captureOffset cap <span class="fu">==</span> <span class="dv">0</span> <span class="kw">of</span>
            <span class="dt">True</span>  <span class="ot">-&gt;</span> (,) (captureSuffix cap) <span class="fu">&lt;$&gt;</span> f mtch
            <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span>

        mtch <span class="fu">=</span> mo re s</code></pre></div>
</div>
<p>It has been used in the library to scan REs so that the captures can be picked out, numbered and that number associated with a name where one has been given.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | scan a RE string into a list of RE Token</span>
<span class="ot">scan ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]
scan <span class="fu">=</span> alex&#39; match al <span class="fu">$</span> oops <span class="st">&quot;top&quot;</span>
  <span class="kw">where</span>
<span class="ot">    al ::</span> [(<span class="dt">Regex</span>,<span class="dt">Match</span> <span class="dt">String</span><span class="ot">-&gt;</span><span class="dt">Maybe</span> <span class="dt">Token</span>)]
    al <span class="fu">=</span>
      [ mk <span class="st">&quot;\\$\\{([^{}]+)\\}\\(&quot;</span> <span class="fu">$</span>         <span class="dt">ECap</span> <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">.</span> x_1
      , mk <span class="st">&quot;\\$\\(&quot;</span>               <span class="fu">$</span> const <span class="fu">$</span> <span class="dt">ECap</span> <span class="dt">Nothing</span>
      , mk <span class="st">&quot;\\(\\?:&quot;</span>              <span class="fu">$</span> const   <span class="dt">PGrp</span>
      , mk <span class="st">&quot;\\(\\?&quot;</span>               <span class="fu">$</span> const   <span class="dt">PCap</span>
      , mk <span class="st">&quot;\\(&quot;</span>                  <span class="fu">$</span> const   <span class="dt">Bra</span>
      , mk <span class="st">&quot;\\\\(.)&quot;</span>              <span class="fu">$</span>         <span class="dt">BS</span>    <span class="fu">.</span> s2c <span class="fu">.</span> x_1
      , mk <span class="st">&quot;(.)&quot;</span>                  <span class="fu">$</span>         <span class="dt">Other</span> <span class="fu">.</span> s2c <span class="fu">.</span> x_1
      ]

    x_1     <span class="fu">=</span> captureText <span class="fu">$</span> <span class="dt">IsCaptureOrdinal</span> <span class="fu">$</span> <span class="dt">CaptureOrdinal</span> <span class="dv">1</span>

    s2c [c] <span class="fu">=</span> c
    s2c _   <span class="fu">=</span> oops <span class="st">&quot;s2c&quot;</span>

    mk s f  <span class="fu">=</span> (either error id <span class="fu">$</span> makeRegexM s,<span class="dt">Just</span> <span class="fu">.</span> f)

    oops  m <span class="fu">=</span> error <span class="fu">$</span> <span class="st">&quot;NamedCaptures.scan: &quot;</span> <span class="fu">++</span> m</code></pre></div>
</div>
<h2 id="find">Find</h2>
<p>The <code>findMatches_</code> function lists all of the files in a directort tree that match an RE.</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- | recursively list all files whose filename matches given RE,</span>
<span class="co">-- sorting the list into ascending order; if the argument path has a</span>
<span class="co">-- trailing &#39;/&#39; then it will be removed</span>
<span class="ot">findMatches_ ::</span> <span class="dt">IsRegex</span> re s <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s <span class="ot">-&gt;</span> re <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]
findMatches_ fm <span class="fu">=</span> findMatches_&#39; fm L.sort matched

<span class="co">-- | recursively list all files whose filename matches given RE,</span>
<span class="co">-- using the given function to determine which matches to accept</span>
<span class="ot">findMatches_&#39; ::</span> <span class="dt">IsRegex</span> re s
              <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s         <span class="co">-- ^ the directory and filepath methods</span>
              <span class="ot">-&gt;</span> ([s]<span class="ot">-&gt;</span>[s])            <span class="co">-- ^ result post-processing function</span>
              <span class="ot">-&gt;</span> (<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Bool</span>)       <span class="co">-- ^ filtering function</span>
              <span class="ot">-&gt;</span> re                    <span class="co">-- ^ re to be matched against the leaf filename</span>
              <span class="ot">-&gt;</span> s                     <span class="co">-- ^ root directory of the search</span>
              <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]
findMatches_&#39; fm srt tst re fp <span class="fu">=</span> srt <span class="fu">&lt;$&gt;</span> find_ fm tst re (packR <span class="st">&quot;&quot;</span>) fp

<span class="ot">find_ ::</span> <span class="dt">IsRegex</span> re s
      <span class="ot">=&gt;</span> <span class="dt">FindMethods</span> s
      <span class="ot">-&gt;</span> (<span class="dt">Match</span> s<span class="ot">-&gt;</span><span class="dt">Bool</span>)
      <span class="ot">-&gt;</span> re
      <span class="ot">-&gt;</span> s
      <span class="ot">-&gt;</span> s
      <span class="ot">-&gt;</span> <span class="dt">IO</span> [s]
find_ fm<span class="fu">@</span><span class="dt">FindMethods</span>{<span class="fu">..</span>} tst re fn fp <span class="fu">=</span> <span class="kw">do</span>
  is_dir <span class="ot">&lt;-</span> doesDirectoryExistDM fp
  <span class="kw">case</span> is_dir <span class="kw">of</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="kw">do</span>
      fns <span class="ot">&lt;-</span> filter ordinary <span class="fu">&lt;$&gt;</span> listDirectoryDM fp
      concat <span class="fu">&lt;$&gt;</span>
        mapM (uncurry <span class="fu">$</span> find_ fm tst re) [ (fn_,abs_path fn_) <span class="fu">|</span> fn_<span class="ot">&lt;-</span>fns ]
    <span class="dt">False</span> <span class="ot">-&gt;</span> return [ fp <span class="fu">|</span> lengthR fp <span class="fu">/=</span> <span class="dv">0</span> <span class="fu">&amp;&amp;</span> tst (matchOnce re fn) ]
  <span class="kw">where</span>
    abs_path fn_ <span class="fu">=</span> fp <span class="ot">`combineDM`</span> fn_
    ordinary fn_ <span class="fu">=</span> not <span class="fu">$</span> fn_ <span class="ot">`elem`</span> [packR <span class="st">&quot;.&quot;</span>,packR <span class="st">&quot;..&quot;</span>]</code></pre></div>
</div>
<p>It is used by the <a href="re-sort-imports"><code>re-sort-imports</code></a> program to discover all of the Haskell scripts in the regex source tree and sort their import statements into a standard order (ultimately using the above-mentioned <code>sortImport</code> function).</p>
<div class="includedcodeblock">
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">sort_r ::</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
sort_r md root <span class="fu">=</span> findMatches_ fm [re<span class="fu">|</span>\<span class="fu">.</span>l<span class="fu">?</span>hs<span class="fu">|</span>] root <span class="fu">&gt;&gt;=</span> sort_these md root
  <span class="kw">where</span>
    fm <span class="fu">=</span> <span class="dt">FindMethods</span>
      { doesDirectoryExistDM <span class="fu">=</span> doesDirectoryExist
      , listDirectoryDM      <span class="fu">=</span> getDirectoryContents
      , combineDM            <span class="fu">=</span> (<span class="fu">&lt;/&gt;</span>)
      }</code></pre></div>
</div>
</div>    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-92650418-1', 'auto');
      ga('send', 'pageview');

    </script>
</body>
</html>
